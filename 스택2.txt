# 완전탐색을 통해서 부분집합의 합을 구하는 법
'''
def f(n, k, s): # 포함 여부를 검토할 원소의 인덱스 n, 배열의 크기 k
                # n-1까지 고려한 부분집합의 합 s
    global cnt  # 재귀호출이 총 몇번 있는지 알아보기 위한 변수
    cnt += 1
    global ans

    if n == k: # 모든 원소가 고려되면
        if s == 10:  # 합이 10인 경우는 총 몇번?
            ans +=1
        print(s)
    else:
        f(n+1, k, s) # n번 원소가 포함되지 않은 부분집합의 합
        f(n + 1, k, s + A[n])  # n번 원소가 포함된 부분집합의 합

A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
cnt = 0
ans = 0
f(0, 10, 0)
print(ans, cnt)
'''

'''
def f(n, k, s):  # 포함 여부를 검토할 원소의 인덱스 n, 배열의 크기 k


    # n-1까지 고려한 부분집합의 합 s
    global cnt  # 재귀호출이 총 몇번 있는지 알아보기 위한 변수
    cnt += 1
    global ans

    if n == k:  # 모든 원소가 고려되면
        if s == 10:  # 합이 10인 경우는 총 몇번?
            ans += 1
    elif s > 10:  # elif 를 집어 넣으면 재귀호출이 확 줄어든다!!!!!
	      # 이전에 고려한 원소의 합이 10보다 크면 중단
        return
    else:
        f(n + 1, k, s)  # n번 원소가 포함되지 않은 부분집합의 합
        f(n + 1, k, s + A[n])  # n번 원소가 포함된 부분집합의 합

A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
cnt = 0
ans = 0
f(0, 10, 0)
print(ans, cnt)
'''

# 합이 55보다 큰 경우는 없으니깐 재귀호출이 끝까지 반복된다!
'''
def f(n, k, s):  # 포함 여부를 검토할 원소의 인덱스 n, 배열의 크기 k
    # n-1까지 고려한 부분집합의 합 s
    global cnt  # 재귀호출이 총 몇번 있는지 알아보기 위한 변수
    cnt += 1
    global ans

    if n == k:  # 모든 원소가 고려되면
        if s == 55:  # 합이 10인 경우는 총 몇번?
            ans += 1
    elif s > 55:  # elif 를 집어 넣으면 재귀호출이 확 줄어든다!!!!!
        return
    else:
        f(n + 1, k, s)  # n번 원소가 포함되지 않은 부분집합의 합
        f(n + 1, k, s + A[n])  # n번 원소가 포함된 부분집합의 합

A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
cnt = 0
ans = 0
f(0, 10, 0)
print(ans, cnt)
'''
'''
# 주어진 숫자를 1번씩 사용해 순열만들기
def f(n, k):
    if n == k:
        print(p)
    else:
        for i in range(k):
            if used[i] == 0: # i번 원소가 사용되지 않았으면
                used[i] = 1 # 사용함으로 표시
                p[n] = A[i]
                f(n+1, k) # n+1원소 결정
                used[i] = 0 # 다른 자리에서 사용하도록 풀어줌!


A = [1,2,3]
used = [0]*3
p = [0]*3
f(0,3)
'''
'''
# 주어진 숫자를 1번씩 사용해 순열만들기
def f(n, k, m):
    if n == k:
        print(p)
    else:
        for i in range(m):
            if used[i] == 0: # i번 원소가 사용되지 않았으면
                used[i] = 1 # 사용함으로 표시
                p[n] = A[i]
                f(n+1, k, m) # n+1원소 결정
                used[i] = 0 # 다른 자리에서 사용하도록 풀어줌!


A = [1,2,3,4,5]
used = [0]*5
p = [0]*5
p[0] = 2  # -> 여기에 어떤 숫자를 넣느냐에 따라 어떤 숫자로 시작하는지 정할 수 있다.
used[1] = 1
f(1, 3, 5)
'''